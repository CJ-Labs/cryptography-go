KZG 多项式承诺方案详解
# 1. 基础概念
## 1.1 什么是 KZG 承诺？
KZG (Kate-Zaverucha-Goldberg) 承诺是一种多项式承诺方案，允许：
- 对一个多项式进行简短的承诺
- 证明多项式在某点的取值
- 验证这个取值的正确性
1.2 核心组件
- 多项式 (Polynomial)
    - 形如 ```f(x) = ax² + bx + c``` 的数学表达式
    - 在代码中用系数数组表示：```[c, b, a]```
- 承诺 (Commitment)
    - 多项式的"指纹"
    - 是椭圆曲线上的一个点
- 证明 (Proof)
    - 包含多项式在某点的值
    - 包含一个证明值，用于验证该值的正确性
# 2. 数学原理
## 2.1 基本步骤
1. Setup (可信设置)
- 选择随机值 τ
- 计算 ```[G, τG, τ²G, ..., τⁿG] 和 [H, τH]```
2. Commit (生成承诺)
- 对于多项式 ```f(x) = Σ cᵢxⁱ```
- 承诺 ```C = Σ(cᵢ * τⁱG)```
3. CreateProof (生成证明)
- 计算 f(z)
- 计算商多项式 ```q(x) = (f(x) - f(z))/(x - z)```
- 生成商多项式的承诺作为证明
## 2.2 示例计算
- 以 ```f(x) = 1 + 2x + 3x²``` 为例：
```
在 x = 2 时：
f(2) = 1 + 2(2) + 3(2²) = 17

商多项式 q(x) = (f(x) - 17)/(x - 2)
               = (3x² + 2x + 1 - 17)/(x - 2)
               = 3x + 8
```
# 3. 代码实现
## 3.1 主要数据结构
```go
type KZG struct {
    G1Powers  []bn254.G1Affine // [G, τG, τ²G, ..., τⁿG]
    G2Powers  []bn254.G2Affine // [H, τH]
    MaxDegree int
    Modulus   *big.Int
}

type Polynomial struct {
    Coefficients []fr.Element
}

type Commitment struct {
    Value bn254.G1Affine
}

type Proof struct {
    Value   fr.Element
    ProofG1 bn254.G1Affine
}
```
## 3.2 核心函数
1. ```Setup```
- 生成可信设置参数
- 计算必要的椭圆曲线点序列
2. ```Commit```
- 接收多项式系数
- 生成承诺值
3. ```CreateProof```
- 计算多项式在指定点的值
- 生成证明值
4. ```Verify```
- 验证证明的正确性
- 使用配对运算进行验证
# 4. 应用场景
## 4.1 零知识证明系统
- 用于 ```Plonk```、```Sonic``` 等协议
- 提供简短的证明大小
## 4.2 区块链扩容
- 用于 rollup 方案
- 数据可用性采样
# 5. 安全性考虑
## 5.1 可信设置
- τ 值必须安全生成和销毁
- 通常通过多方计算仪式生成
## 5.2 密码学假设
- 基于椭圆曲线离散对数难题
- 基于双线性配对的安全性

# 6. 常见问题
## 6.1 性能考虑
- Setup 阶段计算量大
- 验证速度相对较快
- 承诺和证明大小都是常数级
## 6.2 局限性
- 需要可信设置
- 对量子计算不安全
- 设置大小与多项式度成正比
# 7. 总结
- KZG 承诺方案是现代零知识证明系统的重要组成部分，它提供了：
- 简短的承诺大小
- 高效的验证过程
- 可组合性
- 适用于各种应用场景


## commit
- 仿射坐标 (Affine): (x, y) 形式，适合存储和传输
- 雅可比坐标 (Jacobian): (X, Y, Z) 形式，适合计算
#### 优化技术:
- 使用雅可比坐标进行中间计算
- 使用混合加法（AddMixed）提高效率
- 只在最后转换回仿射坐标
#### 数学原理:
- 承诺值 ```C = Σ(cᵢ [τⁱ]₁)```
- cᵢ 是多项式系数
- [τⁱ]₁ 是 SRS 中的 G1 点

## 商多项式计算详解
- 原始多项式：```f(x) = ax² + bx + c```
- 评估点：z
- 多项式值：```f(z) = az² + bz + c```
### 1. 分子计算
```
f(x) - f(z) = (ax² + bx + c) - (az² + bz + c)
             = ax² + bx + c - az² - bz - c
             = ax² + bx - az² - bz
             = a(x² - z²) + b(x - z)
             = (x - z)(ax + az + b)
```
### 2. 商多项式
```
q(x) = (f(x) - f(z))/(x - z)
     = ax + (az + b)
```
#### 3. 具体例子
```
设 f(x) = 3x² + 2x + 1
在点 z = 2 处：

1. 计算 f(2):
   f(2) = 3(2²) + 2(2) + 1
        = 12 + 4 + 1
        = 17
2. 计算 f(x) - f(2):
   f(x) - f(2) = (3x² + 2x + 1) - 17
               = 3x² + 2x - 16

3. 计算商多项式 q(x):
   q(x) = (3x² + 2x - 16)/(x - 2)
        = 3x + 8

验证：
q(x) * (x - 2) = (3x + 8)(x - 2)
               = 3x² - 6x + 8x - 16
               = 3x² + 2x - 16
               = f(x) - f(2)
```

### 4. 为什么需要商多项式？
1. 零知识性质：
- 商多项式是证明系统的关键部分
- 它证明了 f(z) 确实是多项式在 z 点的值
2. 验证等式
- ```f(x) - f(z) = q(x)(x - z)```
- 这个等式在配对验证中被使用
- 验证者不需要知道完整的多项式 f(x)
3. 效率
- 商多项式的度比原多项式小 1
- 这使得证明大小保持恒定

### 5. 数学原理
对于任意多项式 f(x) 和点 z：
- 1. f(x) - f(z) 一定可以被 (x - z) 整除
- 2. 商就是我们的 q(x)
- 3. 度数会减少 1

这是多项式代数的基本性质，源于因式定理